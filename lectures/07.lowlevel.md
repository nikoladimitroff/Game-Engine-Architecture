# Game Engine Architecture

## Engine support (low-level) systems

---------------------
[Course Index](http://nikoladimitroff.github.io/Game-Engine-Architecture)

<div class="authors-section">
<table>
<tbody>
    <tr>
        <td>
            Nikola Dimitroff
        </td>
        <td>
            <a target="_blank" href="https://dimitroff.bg"><i class="fa fa-rss"></i></a>
            <a target="_blank" href="mailto:nikola@dimitroff.bg"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/nikoladimitroff"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/nikoladimitroff"><i class="fa fa-twitter"></i></a>
        </td>
    </tr>
    <tr>
        <td>
            Alexander Angelov
        </td>
        <td>
            <a target="_blank" href="mailto:aleksandar.angelovv@gmail.com"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/Alekssasho"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/Alekssasho"><i class="fa fa-twitter"></i></a>
        </td>
    </tr>
    <tr>
        <td>
            Viktor Ketipov
        </td>
        <td>
            <a target="_blank" href="mailto:viktor@kipiinteractive.com"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/k1p1"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/xk1p1x"><i class="fa fa-twitter"></i></a></p>
        </td>
    </tr>
</tbody>
</table>
</div>

<div class="companies-section">
<a class="ubisoft-logo" href="https://ubisoft.com" target="_blank"></a>
<br>
<a class="kipi-logo" href="http://kipiinteractive.com" target="_blank"></a>
</div>

--- VERTICAL SLIDE ---

TODO MOVE THIS SLIDES TO WHERE APPROPRIATE
TODO ADD GARBAGE COLLECTOR
`std::unique_ptr` has a second template parameter

```cpp
struct CustomDeleter
{
    void operator()(void* p)
    {
        std::cout << "Instance " << p << " is dead now";
    }
};
...
std::unique_ptr<NPC, CustomerDeleter> npc;
```
--- VERTICAL SLIDE ---

How does one delete a object allocated with custom allocator?

* There is no custom syntax for `delete`!
* Invent your own (e.g. use custom deleter)

```cpp
template<typename T>
struct PerFrameDeleter
{
    void operator()(void* instance)
    {
        instance->~T();
        g_PerFrameAllocator->Deallocate(instance);
    }
};
...
std::unique_ptr<Player, PerFrameDeleter> player
    (new (&g_PerFrameAllocator) Player());
```

--- VERTICAL SLIDE ---

###### A good logging libraries has

* Severities so you can ignore unimportant info but still have it there if needed
* Categories so you can filter messages in one system
* Log to file, console, etc.
* Timing info
* Compile time and run-time impact

--- VERTICAL SLIDE ---

```cpp
Logger* gLogger;
...
void SpawnEntity(const EntityDescription& d)
{
    ...
    if (too many entities)
    {
        logger->Log(Severity::Error,
            Category::SpawningService,
            "Couldn't spawn requested entity of type <%s>",
            d.TypeName);
        // [1.1.1970 23:59:59][Spawning] Error: Couldn't spawn <Al Mualim>
    }
}
```

--- VERTICAL SLIDE ---

###### Choosing a logging library

* There is no standard `C++` library for logging.
* Logging is an aspect of the program
* It crawls all over the place

--- VERTICAL SLIDE ---

###### Logging libraries

* [glog][glog]
* [boost log][boost]
* Lots of them on github
* roll your own (at least for fun)

[glog]: https://code.google.com/p/google-glog/
[boost]: http://www.boost.org/doc/libs/1_60_0/libs/log/doc/html/index.html

--- VERTICAL SLIDE ---

###### What to log?

* Not too much (it is not free), but enough to understand what
  is going on.
* All important points in the lifetime of the application
    * Acquiring and releasing resources
    * Creating and destroying game entities
    * Machine info, game version

--- VERTICAL SLIDE ---

## Crash reporting

At the end there will be crashes

--- VERTICAL SLIDE ---

All operating systems allow registering of custom callback to be called
when the application crashes

--- VERTICAL SLIDE ---

You gather everything you can about the state and send it back home to be
examined.

--- VERTICAL SLIDE ---

### [Breakpad](https://code.google.com/p/google-breakpad/)

* portable
* allows automatic crash dump analysis


### Memory management

C++ has support for custom memory management
(*why we use it in the first place*)

* `operator new` and `operator delete` are overridable and overloadable
* each class can have its own
* STL containers have support for custom allocators

--- VERTICAL SLIDE ---

References:

* [`operator new`](http://en.cppreference.com/w/cpp/memory/new/operator_new)
* [`operator delete`](http://en.cppreference.com/w/cpp/memory/new/operator_delete)

--- VERTICAL SLIDE ---

Overriding `new` & `delete`

```cpp
void* operator new(std::size_t size)
{
    // Ask Windows for memory
    // YOU DON'T HAVE TO UNDERSTAND THIS CODE
    void* memory = VirtualAlloc(NULL,
        size,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);
    return memory;
}
void operator delete(void* ptr)
{
    // Return the memory to Windows
    VirtualFree(ptr, 0, MEM_RELEASE);
}
```

--- VERTICAL SLIDE ---

#### Cons

These operators are global

* no information from the call site or the type
* no state (except global)
* prone to need mutex for multithreading

There's a better way

--- VERTICAL SLIDE ---

Placement `new`

```cpp
// Allocate memory (stack, heap, w/e)
char buffer[256];
// Construct Player in buffer
auto player = new (buffer) Player;
// Destroy the player instance, but memory is still allocated
player->~Player();
```

--- VERTICAL SLIDE ---

`operator new` has a bunch of other overloads

```cpp
void* operator new(std::size_t size, void* ptr);
void* operator new[](std::size_t size, void* ptr);
void* operator new(std::size_t size, user-defined-args...);
void* operator new[](std::size_t size, user-defined-args...);
```

--- VERTICAL SLIDE ---

```cpp
struct LinearAllocator {
    // Statically allocate 1 MB of memory
    char m_Buffer[1024 * 1024];
    int m_Offset;
    int m_BufferSize;
    void* Allocate(size_t size)
    {
        if (offset + size > m_BufferSize)
            return nullptr; // or crash!

        auto ptr = m_Buffer + m_Offset;
        m_Offset += size;
        return ptr;
    }
} g_PerFrameAllocator;
```

--- VERTICAL SLIDE ---

```cpp
void* operator new(std::size_t size, LinearAllocator* allocator)
{
    return allocator->Allocate(size);
}
...
// Create a new instance in the memory of the per-frame allocators
auto models = new (&g_PerFrameAllocator) Models();
```

--- VERTICAL SLIDE ---

#### STL allocator

* [`allocator`](http://en.cppreference.com/w/cpp/memory/allocator)

* `std::vector<int, MyCustomAllocator>` will forward all allocations to `MyCustomAllocator`

--- NEXT SLIDE ---

# Sanity check

We are recording, aren't we?

![kitty cameraman](http://www.catster.com/wp-content/uploads/2015/06/335f4392f011a80324e09f5ace0b3f57.jpg)

--- NEXT SLIDE ---

## Review

How do we use time in games?

* <!-- .element class="fragment" data-fragment-index="0" --> Use it for all gameplay purposes
* <!-- .element class="fragment" data-fragment-index="1" --> Don't accumulate it
* <!-- .element class="fragment" data-fragment-index="2" --> Don't use floats for storage

--- VERTICAL SLIDE ---

Compare & contrast task & thread based parallelism

* <!-- .element class="fragment" data-fragment-index="0" --> Threads-based means dedicating a specific thread for a specific set of operations
* <!-- .element class="fragment" data-fragment-index="1" --> Task-based means any thread can execute any task

--- VERTICAL SLIDE ---

Compare & contrast SoA & AoS

* <!-- .element class="fragment" data-fragment-index="0" --> One is cache-friendly & fast, the other isn't

--- NEXT SLIDE ---

## Low-level systems

1. Subsystem start and shutdown
1. Memory Management. Allocators.
1. Resources and file system
1. Cooking and backing content
1. Configuration

--- NEXT SLIDE ---

### Subsystems

?

--- VERTICAL SLIDE ---

- Memory Management
- Logging
- IO and Assets
- Networking
- Physics
- Input
- Visual Effects
- Rendering
- Gameplay
- Scripting

--- NEXT SLIDE ---

How a subsystem is represented in the code?

- a separate library
- a singleton

--- NEXT SLIDE ---

#### A separate library

- properly separated interface from implementation
  - can be tested in isolation
  - better build times
  - plugin systems
    - 2D vs 3D physics / rendering
    - different scripting engines
    - only cooked content in production builds

--- NEXT SLIDE ---

#### A singleton

For most subsystems it is convenient to be implemented as a singleton.

--- VERTICAL SLIDE ---

- Allocator per subsystem
- Logger
- IO
- Scripting Engine
- ...

--- VERTICAL SLIDE ---

##### Singleton Simple style

```
extern Allocator* g_Allocator;
extern Logger* g_Logger;
int main() {
    g_Allocator = Memory::Initialize();
    g_Logger = Logging::Initialize();

    while (1) {
        // amuse
    }

    Logging::Shutdown(g_Logger);
    Memory::Shutdown(g_Allocator);
    return 0;
}
```

--- VERTICAL SLIDE ---

- Order is explicit (so are dependencies)
- Order of `shutdown` might be different

--- VERTICAL SLIDE ---

- There are other ways to do Singleton, but this is C++ specific,
and has nothing to do with engine design

--- NEXT SLIDE ---

## Memory Management

is hard

--- NEXT SLIDE ---

- memory is limited
- allocation is slow

--- NEXT SLIDE ---

- Memory is limited
  - phones
  - consoles
  - PC -> Shipping a title for China -> XP - 32 bit, 3GB at max

--- VERTICAL SLIDE ---

- Memory budget per subsystem / feature
- How to enforce a budget?
  - by tracking
    - a different allocator for each subsystem

--- VERTICAL SLIDE ---

```cpp
enum class SubsystemTags { ... };
template<T, SubsystemTags Tag>
class TaggedAllocator
{...};

#define IMPLEMENT_SUBSYSTEM_TYPES(Subsystem, Tag)\
    template<typename T> \
    using Subsystem##UniquePtr = std::unique_ptr<T, TaggedAllocator<T, Tag>>;
    ...

void Physics::Update(float dt)
{
    IMPLEMENT_SUBSYSTEM_TYPES(Physics, SubsystemTags::Physics);
    PhysicsUniquePtr collider(new Collider3D());
    ...
};
```

--- VERTICAL SLIDE ---

- Allocation is slow

--- VERTICAL SLIDE ---

- `malloc`* and `new`* are general purpose
  - have to handle from 0 to tens of GBs allocations
  - in any order
  - in any thread
- Fragmentation

--- VERTICAL SLIDE ---

- Pre-allocate all the memory on start and use it later
  - used in spaceships / cars / planes other
  hard realtime  systems
- If we use again a general purpose allocator, it will be again slow
- Use allocators chosen for the particular pattern of allocations and usage

--- VERTICAL SLIDE ---

### Stack (linear) allocator

- Preallocate a block of memory
- `allocate` portions of this block using a stack behaviour
  - `allocate` just moves a pointer further in the block
  - `free` *should* move the pointer back

--- VERTICAL SLIDE ---

Since the `free` is not always in the opposite order, it is simpler to actually
never free memory. Instead the allocation pointer is reset to a certain value
position from time to time.

--- VERTICAL SLIDE ---

![Stack Allocator](resources/07.lowlevel/stack.jpg)

--- VERTICAL SLIDE ---

[Sample
implementation](https://stoyannk.wordpress.com/2015/05/31/temporary-allocations-in-c/)

--- VERTICAL SLIDE ---

### Double-ended stack allocators

- use two ends of the pre-allocated block to allocate / free memory
- one end for memory blocks that are likely to stay for long time
  - i.e. current level / map
- the other end for temporary blocks that are not going to live more than a
  frame

--- VERTICAL SLIDE ---

### Pool allocator

All objects from a given type have the same size.

- Preallocate a large memory block and use it for a single size / type
  allocations

--- VERTICAL SLIDE ---

- Store a free-list of the free blocks
- Single linked list
- Since the block is free, we can store *next* pointer in the block

--- VERTICAL SLIDE ---

```
class PoolAllocator {
    PoolAllocator(int objectSize, int objectCount);
    void* Allocate();
    void Free(void*);

    int ObjectSize;
    int Objects;
    char* Buffer;
    char* FreeHead;
};
```

--- VERTICAL SLIDE ---

```
PoolAllocator::PoolAllocator(int objectSize, int objectCount)
    : ObjectSize(objectSize)
    , ObjectCount(objectCount)
    , Buffer(new char[ObjectSize * ObjectCount])
    , FreeHead(Buffer)
{
    for (int i = 0; i < objectCount; ++i) {
        *(char**)(Buffer+i) = Buffer + i + 1;
    }
}
```

--- VERTICAL SLIDE ---

```
void* PoolAllocator::Allocate() {
    // Get the first free block
    auto block = m_FreeHead;
    // Change the head to the next block
    m_FreeHead = *(char**)(block);
    // Return the block
    return block;
}
```

--- VERTICAL SLIDE ---

```
void PoolAllocator::Free(void* block) {
    *(char**)block = m_FreeHead;
    m_FreeHead = block;
}
```

--- VERTICAL SLIDE ---

#### Fragmentation

![Fragmentation](resources/07.lowlevel/fragmentation.jpg)

--- VERTICAL SLIDE ---

- there is no fragmentation in stack allocators
- Pool Allocators might be fragmented, but it doesn't matter
  - as long as there is a free slot, it will be enough for an allocation


--- VERTICAL SLIDE ---

### Alignment

- some systems require objects to be aligned for some instructions
  - SIMD instructions on ARM

--- VERTICAL SLIDE ---

```cpp
// Note: alignment must be a power of two
void* simpleAllocateAligned(size_t size, size_t alignment)
{
    void* unaligned = allocate(size + alignment); // Assume unaligned = 0xDEADCAFE
    size_t mask = alignment - 1; // Assume alignment = 16, mask is then 0x0000000F
    size_t misalignment = unaligned & mask; // = 0x0000000E
    size_t adjustment = alignment - misalignment; // = 1
    void* aligned = unaligned + adjustment;
    return aligned;
}
```

--- NEXT SLIDE ---

## Resources and IO

--- NEXT SLIDE ---

- File access is bad
  - it is slow
  - it is different on each platform

--- NEXT SLIDE ---

### The filesystem is different on each platform

- Windows - case-insensitive
- Posix - case-sensitive
- Mac OS X - depends on how the disk is mounted!

--- VERTICAL SLIDE ---

- *C:* - drive letter is only on Windows
- Consoles and phones have some prefixes for card, dvd, hdd
- Consoles and phones restrict access to the filesystem
- All OSes restrict write access for regular users
  - installing the game in a system folder and logging next to the executable...

--- VERTICAL SLIDE ---

- Just opening a file is slow
- IO is slow
  - buffered several reads / writes are free, but the real ones are slower

--- VERTICAL SLIDE ---

![HDD Scheme](https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Cylinder_Head_Sector.svg/512px-Cylinder_Head_Sector.svg.png)

--- VERTICAL SLIDE ---

- Disk is often a bottleneck
- DVDs are slow
- SSDs are small and expensive
- cards on phones are slow (People go for more MBs)

--- VERTICAL SLIDE ---

- There is a single disk controller on most systems
- No point in having multiple threads for IO, if the IO is bottleneck

--- VERTICAL SLIDE ---

Most game engines have a dedicated IO thread

- or all IO tasks are combined, so they are not executed at the same time

--- VERTICAL SLIDE ---

#### OSes support asynchronous IO

- We can do many IO operations without waiting and blocking
- The game code already is using asynchronous IO, because IO is another thread.

--- NEXT SLIDE ---

- Traversing a folder structure is slow
    - *Content/Meshes/Characters/Player/Mario.collada*
      - each slash is a read the directory descriptor, find the entry and repeat
- Having files out in the open is not a good idea
  - easier to take out content
  - easier to cheat by changing content

--- VERTICAL SLIDE ---

So what are our options?

--- VERTICAL SLIDE ---

#### Virtual filesystem

- API that behaves like a filesystem, but reads the files from some kind of an
  archive (zip, lzma, ...)
  - no need to worry about slashes, symbols, roots, drives, etc
- can use multiple archives to allow updates and partial installs
  - Original *content-0.pak* content
  - Patch 1.1 contains *content-1.pak*, which can override content in
    *content-0*

--- VERTICAL SLIDE ---

- The structure is fixed, so there can be a single global index
  - *Content/Meshes/Characters/Player/Mario.collada* can be a single
    lookup

--- VERTICAL SLIDE ---

- Can have a special structure, orthogonal to the folder structure
  - all the textures for a model can be stored after the model
      - improves read speed from the DVD
- Can use compression to reduce download and install times
  - copying a single large faster is much faster than a large number of small
    files
- Support streaming
  - install only the vital assets with the game, stream the rest while the
    player is playing


--- VERTICAL SLIDE ---

#### Asset streaming

- Games have lots of content, even free-to-play
    - bandwidth is not free
    - players do not want to wait
- Download only the game and the content for the first level
- Download everything else, once the player is in the game

--- VERTICAL SLIDE ---

### Resource references

- Paths are human-friendly
  - hierarchical organization
- Paths are not efficient for computers
  - strings - heap allocations, take up memory, mess up caches

--- VERTICAL SLIDE ---

#### GUIDs

Global (Universally) Unique IDentifiers

- 128 bit integer

--- VERTICAL SLIDE ---

- Generate a GUID for each resource
  - or even each revision of a resource
- at asset-cook-time replace all asset references with the appropriate guids


--- VERTICAL SLIDE ---

#### Hashes

- Replace the path of an asset with its hash

- If a path comes from somewhere, it is still easy to find the resource
  * GUIDs will need a lookup table

--- VERTICAL SLIDE ---

##### Perfect hashes

If the hash is not perfect, we'll still have to keep the full path around to
allow conflict resolution.

The set of assets is known in the game, so a perfect hash can be used. This will
allow replacing asset references with a single int.

--- VERTICAL SLIDE ---

### [`gperf`](https://www.gnu.org/software/gperf/)
  - given a set of strings will generate a perfect-hash function
  - will use mininum computations
  - will use minimal hash function - for $N$ strings, $Max(Hash(s))$ will be close to
    $N$
  - adding resources requires recooking (to generate a new hash function)

--- VERTICAL SLIDE ---

### [*MurmurHash*](https://en.wikipedia.org/wiki/MurmurHash) with a special seed
  - at asset-cook-time, find a seed for the *Murmur/City* hash algorithms that
    generate a perfect hash function
  - just read the seed at startup, eventually remap hashes

--- NEXT SLIDE ---

#### Asset cooking

The process of converting development content to shipping content

- development content
  - human-friendly - paths, text-based, etc.
  - content-creation tools friendly
    - models in 3D Studio MAX, Maya, COLLADA formats
    - textures in PSD, TIFF
- shipping content
  - hashes for paths
  - models as sets of vertices, indices, material ids & texture ids
  - textures in GPU compressed formats

--- VERTICAL SLIDE ---

##### Image formats

- PNG - mostly RGBA_8 - 32 bits per pixel
- JPEG - lossy

Both are expensive to decode at runtime and consume a lot of memory

--- VERTICAL SLIDE ---

- 2s spritesheet animation of a 100px * 100 px

$$
120 \* 100 \* 100 \* 4 = 4800000 = 4.8 MB
$$

- 2s spritesheet animation of a 200px * 200 px

$$
120 \* 200 \* 200 \* 4 = 4 \* 4800000 = 19.2 MB
$$

* https://github.com/mainroach/crabby

--- VERTICAL SLIDE ---

##### GPU texture formats

- Generally lossy formats, but since they are made for GPUs, the lost quality is
  almost invisible
- Each platform has its own:
  - DDS / BC formats for Windows
  - PlayStation 4 has its own
  - PVRTC for iOS
  - ETC format for OpenGL ES 2.0/3.0 (Android)

http://www.reedbeta.com/blog/2012/02/12/understanding-bcn-texture-compression-formats/


--- VERTICAL SLIDE ---

http://mainroach.blogspot.bg/2014/03/the-png-vs-gpu-battle-on-android.html
http://mainroach.blogspot.bg/2014/03/png-bloat-in-android-games.html

--- NEXT SLIDE ---

#### Versioning resources

Assets are binary and large

- hard for Version Control Systems to chew on
  - [Perforce](https://www.perforce.com/)
  - [Github's Git Large-File-Storage](https://git-lfs.github.com/)
  - A couple of other Git based solutions
  - Mercurial largefile support
- Custom, in-house tools
  - Separate metadata from the files
  - store all versions

--- NEXT SLIDE ---

#### Patching resources

- The game checks for updates on start
- If necessary - downloads the new patch, installs it and restarts
  - Patching the executable may require a separate process
- Generating diffs for binary, compressed files is not easy
  - http://xdelta.org/
- Patching a 2 GB pak file, just to add a byte in the middle will be terribly
  slow and might easily fail
  - add the changed content in a new pak file and override the old one

--- NEXT SLIDE ---

### Memory management for Resources

--- NEXT SLIDE ---

- Pool - read files in chunks
- Stack - double ended, or a separate allocator stack

--- VERTICAL SLIDE ---

![Stack Resources](resources/07.lowlevel/level.jpg)

--- NEXT SLIDE ---

- GPU memory has to be managed too

--- NEXT SLIDE ---

## Reflection

Treating code as resources

![Cat in mirror](resources/07.lowlevel/cat_mirror.jpg)

--- VERTICAL SLIDE ---

Reflection is any mechanism that allows for code introspection:

* Looking up / iterating a set of classes or class members by name or type
* Instantiating looked up classes
* Invoking looked up functions; reading / writing to fields
* Creating new classes at runtime
* Basically, `<type_traits>` at runtime

--- VERTICAL SLIDE ---

* Some languages provide out-of-the-box reflection (C#, Java, Python, JS)
* Reflection is much harder to achieve in C++

--- VERTICAL SLIDE ---

#### The ways of reflection

* [RTTI](http://en.cppreference.com/w/cpp/types/type_info)
    - Almost useless, extra-overhead, cannot be configured per-class
* Annotated source code
    - Configurable; lots of boilerplate, error-prone

```cpp
BEGIN_REFLECT(Foo)
class Foo
{
    REFLECT_MEMBER(int, Bar)
    int Bar;
};
END_REFLECT(Foo)
```

--- VERTICAL SLIDE ---

#### The ways of reflection (cont.)

* Compiler hacking
    - use an external tool parsing debugging info / the AST or
    modify an open-source compiler
    - powerful; kind of platform-dependent, un-configurable

--- VERTICAL SLIDE ---

#### The ways of reflection (cont.)

* Custom tool + annotations
    - custom tool looking for certain annotations
    - if found, do magic tricks with the AST to parse the type
    - has all the good things

```cpp
REFLECT_CLASS()
class Foo
{
    REFLECT_PROPERTY()
    int Bar;
};
```

--- NEXT SLIDE ---

### Configuration

Every engine needs basic configuration

- where is the content?
- graphics quality
  - AA, LODs, FOV, etc
- log level

--- VERTICAL SLIDE ---

Gameplay:

- difficulty level
- most of the gameplay is actually configuration
  - speed of time, character movement
  - cost and effect of actions
    - i.e. cost of highway per km vs the number of cars in a city builder game

There are games, whose gameplay is written entirely in configuration files

--- NEXT SLIDE ---

- Text vs. binary files
- Local vs. cloud storage

--- VERTICAL SLIDE ---

#### Text files

- *ini* files
  - very simple and quite popular
  - no complex structures
- *json* - not very human friendly
- *xml* - no, just don't
- custom format
  - boost has a library for that
- full scale programming language, i.e. Lua, JavaScript, Scheme
  - keep the amount of logic in the config sane (or no logic at all)

--- VERTICAL SLIDE ---

Text files have to be parsed

- slow
- makes allocations

--- VERTICAL SLIDE ---

#### Binary files

- not human friendly
- asset cooking can convert a text configuration into a binary one
  - use the text configuration to initialize C++ structures and serialize them

--- VERTICAL SLIDE ---

#### Runtime configuration

- Quake console
  - *cvars* - globally registered variables, that can be tweaked from the
    console
  - Unreal Engine 4 is using a similar system
- Developer menus - can change variables or execute more complex gameplay
  - i.e. craft an item, without having the Crafting interface ready

--- VERTICAL SLIDE ---

#### Runtime configuration

- Terminal / shell in the game
  - add a REPL powered by a scripting language
- RPC / HTTP rest for remote access
  - typing on a console can be difficult
  - allows remote debugging

--- VERTICAL SLIDE ---

#### Storing configurations

- Some platforms restrict the amount of data you can save
- Cloud storage - my settings will be preserved, no matter where I play from
  - requires internet

--- NEXT SLIDE ---

Questions?
